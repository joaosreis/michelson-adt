type n = Nat

type z = Int

type mutez = Mutez

type _ num =
  | N_int : Z.t -> z num
  | N_nat : Z.t -> n num
  | N_mutez : Z.t -> mutez num

type address = Address

type signature = Signature

type key_hash = Key_hash

type key = Key

type timestamp = Timestamp

type _ s_string =
  | S_string : string -> string s_string
  | S_address : string -> address s_string
  | S_signature : string -> signature s_string
  | S_key_hash : string -> key_hash s_string
  | S_key : string -> key s_string
  | S_timestamp : string -> timestamp s_string

type ('a, 'b) pair = Pair of 'a * 'b

type ('a, 'b) union = Or of 'a * 'b

type 'a option = Option of 'a

type ('a, 'b) elt = Elt of 'a * 'b

type 'a t_list = List of 'a

type _ data =
  | D_num : 'a num -> 'a data
  | D_string : 'a s_string -> 'a data
  | D_bytes : string -> bytes data
  | D_unit : unit data
  | D_bool : bool -> bool data
  | D_pair : 'a data * 'b data -> ('a, 'b) pair data
  | D_left : 'a * 'b data -> ('a, 'b) union data
  | D_right : 'b * 'a data -> ('a, 'b) union data
  | D_some : 'a data -> 'a option data
  | D_none : 'a -> 'a option data
  | D_elt : 'a data * 'b data -> ('a, 'b) elt data
  | D_list : 'a data list -> 'a t_list data

let x = D_pair (D_num (Nat Z.one), D_timestamp "x")

let rec what_is_the_type : type a. a data -> Adt.typ = function
  | D_num (Nat _) -> T_nat
  | D_num (Int _) -> T_int
  | D_num (Mutez _) -> T_mutez
  | D_signature _ -> T_signature
  | D_mutez _ -> T_mutez
  | D_address _ -> T_address
  | D_key_hash _ -> T_key_hash
  | D_key _ -> Key
  | D_timestamp _ -> Timestamp
  | D_pair (x, y) -> Pair (what_is_the_type x, what_is_the_type y)
  | D_left (t, d) -> Or (what_is_the_type d, t)
  | D_right (t, d) -> Or (t, what_is_the_type d)

type end_of_stack = unit

type ('arg, 'ret) lambda =
  | Lam :
      ('arg * end_of_stack * 'ret * end_of_stack) * _ (* code *)
      -> ('arg, 'ret) lambda

type comb = Comb

type leaf = Leaf

type (_, _) comparable_struct =
  | Int_key : type_annot option -> (z num, _) comparable_struct
  | Nat_key : type_annot option -> (n num, _) comparable_struct
  | String_key : type_annot option -> (string, _) comparable_struct
  | Bytes_key : type_annot option -> (bytes, _) comparable_struct
  | Mutez_key : type_annot option -> (tez, _) comparable_struct
  | Bool_key : type_annot option -> (bool, _) comparable_struct
  | Key_hash_key : type_annot option -> (public_key_hash, _) comparable_struct
  | Timestamp_key : type_annot option -> (timestamp, _) comparable_struct
  | Address_key : type_annot option -> (address, _) comparable_struct
  | Pair_key :
      (('a, leaf) comparable_struct * field_annot option)
      * (('b, _) comparable_struct * field_annot option)
      * type_annot option
      -> (('a, 'b) pair, comb) comparable_struct

type 'a comparable_ty = ('a, comb) comparable_struct

module type Boxed_set = sig
  type elt

  val elt_ty : elt comparable_ty

  module OPS : S.SET with type elt = elt

  val boxed : OPS.t

  val size : int
end

type 'elt set = (module Boxed_set with type elt = 'elt)

module type Boxed_map = sig
  type key

  type value

  val key_ty : key comparable_ty

  module OPS : S.MAP with type key = key

  val boxed : value OPS.t * int
end

type 'a ty =
  | Unit_t : type_annot option -> unit ty
  | Int_t : type_annot option -> z num ty
  | Nat_t : type_annot option -> n num ty
  | Signature_t : type_annot option -> signature ty
  | String_t : type_annot option -> string ty
  | Bytes_t : type_annot option -> bytes ty
  | Mutez_t : type_annot option -> tez ty
  | Key_hash_t : type_annot option -> public_key_hash ty
  | Key_t : type_annot option -> public_key ty
  | Timestamp_t : type_annot option -> timestamp ty
  | Address_t : type_annot option -> address ty
  | Bool_t : type_annot option -> bool ty
  | Pair_t :
      ('a ty * field_annot option * var_annot option)
      * ('b ty * field_annot option * var_annot option)
      * type_annot option
      * bool
      -> ('a, 'b) pair ty
  | Union_t :
      ('a ty * field_annot option)
      * ('b ty * field_annot option)
      * type_annot option
      * bool
      -> ('a, 'b) union ty
  | Lambda_t : 'arg ty * 'ret ty * type_annot option -> ('arg, 'ret) lambda ty
  | Option_t : 'v ty * type_annot option * bool -> 'v option ty
  | List_t : 'v ty * type_annot option * bool -> 'v list ty
  | Set_t : 'v comparable_ty * type_annot option -> 'v set ty
  | Map_t :
      'k comparable_ty * 'v ty * type_annot option * bool
      -> ('k, 'v) map ty
  | Big_map_t :
      'k comparable_ty * 'v ty * type_annot option
      -> ('k, 'v) big_map ty
  | Contract_t : 'arg ty * type_annot option -> 'arg typed_contract ty
  | Operation_t : type_annot option -> operation ty
  | Chain_id_t : type_annot option -> Chain_id.t ty
